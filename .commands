vi ~/.commands
---------------------------------------------------------------------------------------------------- git & github
# List repositories for a specific user or organization
gh repo list <username/org>
# Clone a repository from one of your organizations
gh org list

org=$(gh org list | fzf) && repo=$(gh repo list "$org" | fzf | awk '{print $1}') && gh repo clone "$repo"

# Create branch from git rev
git checkout -b <new-branch-name> [<start-point>]

# branch 관리: 로컬에서 필요없는 remote upstream 지우기
git branch -d -r <remote-name>/<bracnh-name>

git push origin --delete <branch-name>

# local branch가 어떤 remote branch와 연결되었지 (있다면)표시
git branch -vv
# local branch와 연결된 upstream 제거(git push하면 자동으로 upstream 설정으로 upload됨)
git branch --unset-upstream <local-branch-name>
# Rename the current branch
git branch -m [<old-branch>] <new-branch>

# 직전 revision 되돌리기(기록 남기면서). 구간 지정도 가능한데, conflict 발생 가능하다.
git revert HEAD

# 다운받기 전에 확인만
git fetch --dry-run

# PR 생성: 기본 브랜치 지정
gh pr create --base <base-branch>

# 특정 리포지토리에 PR 생성
gh pr create --repo greyHairChooseLife/jg-websocket --base main

# PR 병합
gh pr merge <pr-number>

# PR diff 확인 (delta와 함께 사용 가능)
gh pr diff <pr-number>

# PR 체크아웃
gh pr checkout <pr-number>

# Issue 생성
gh issue create

# Issue 목록 조회
gh issue list

# Issue 상세 보기
gh issue view <issue-number>

# Issue 편집
gh issue edit <issue-number>

# Issue 닫기
gh issue close <issue-number>

# Issue 다시 열기
gh issue reopen <issue-number>

# Issue에 댓글 추가
gh issue comment <issue-number>

# Issue에 담당자 할당
gh issue assign <issue-number>


---------------------------------------------------------------------------------------------------- gh gist
gh gist edit $(gh gist list -L 30 | column -t -s $'\t' | fzf | awk '{print $1}')

gh gist clone $(gh gist list -L 30 | column -t -s $'\t' | fzf | awk '{print $1}')

---------------------------------------------------------------------------------------------------- appendix
| column -t -s $'\t'

| awk '{print $3}'

| sed -i 's/old-string/new-string/g'
# Delete the 2nd line:
| sed '2d'
# Delete lines 2 to 4:
| sed '2,4d'
# Delete lines matching a pattern (e.g., starting with "my"):
| sed '/^my/d'
# case sensitive
| grep -s "Call stack"
# only matched (instead of entire line)
| grep -o -- "0x.*[0-9a-f]"
---------------------------------------------------------------------------------------------------- misc
# grep around 5 lines
rg -C 5 "pattern" /path/to/file
# NOT starting with "test"
rg -v "^test" file.txt
# Replace a string in a file (in-place) using sed
# Print the 9th column of a command's output (useful for `ls -l`)
sed -i 's/old-string/new-string/g' filename.txt

ls -l | awk '{print $3}'
# Monitor a command's output, updating every second
watch -n 1 'command'

# Set the desktop background with feh
feh --bg-scale /path/to/image.jpg
# Extract a range of pages from a PDF
pdfseparate -f <first_page_number> -l <last_page_number> input.pdf page_%d.pdf

pdfunite page_*.pdf output.pdf
# Compress a PDF to a smaller size (for ebooks)
ghostscript -sDEVICE=pdfwrite -dPDFSETTINGS=/ebook -o small.pdf large.pdf
# Combine multiple PDF files into one
pdfunite file1.pdf file2.pdf output.pdf

# what is this?
type <alias or function>
---------------------------------------------------------------------------------------------------- hardware
# Save the current display layout to a profile with autorandr
autorandr --save <profile-name>
# Load a saved display profile
autorandr --load <profile-name>
# Let autorandr automatically detect and apply the correct profile
autorandr --change
# Check battery status and charge thresholds
tlp-stat -b

sudo tlp fullcharge
# Set battery charge thresholds (e.g., start at 75%, stop at 80%)
sudo tlp setcharge 75 80 BAT0
# Calibrate the battery (run on AC power)
sudo tlp recalibrate
# Get detailed CPU information
lscpu
# Show memory usage details
cat /proc/meminfo
# List block devices (disks and partitions)
lsblk
# Show kernel version and system info
uname -a
# View a process tree
pstree


# 모니터
mons -S 0,7:R

xrandr --output DP-2-2 --mode 1920x1200 --rotate left


---------------------------------------------------------------------------------------------------- C-language
# Compile a C file with debug symbols and no optimizations
gcc -g -O0 main.c -o main.out
# Generate a `compile_commands.json` file for a make-based project
bear -- make

---------------------------------------------------------------------------------------------------- debugging
# Disassemble an executable and interleave with source code, view in less
objdump -d -S a.out | less

---------------------------------------------------------------------------------------------------- Docker
# --- Docker ---
# Build a Docker image from a Dockerfile in the 'config' directory
docker build -t <my-image-name> -f <path/to/Dockerfile>
# Run a container in detached mode with a volume mount
docker run -d --name <container_name> -v </host/path>:</container/path> <img_name>
# Execute a shell inside a running container
docker exec -it <container_name> bash
# List all containers (running and stopped)
docker ps -a
# 'config' 디렉토리의 Dockerfile에서 Docker 이미지를 빌드
docker build -t <my-image-name> -f <path/to/Dockerfile>
# 분리 모드로 볼륨 마운트와 함께 컨테이너 실행
docker run -d --name <container_name> -v </host/path>:</container/path> <img_name>
# 실행 중인 컨테이너 내부에서 셸 실행
docker exec -it <container_name> bash
# 모든 컨테이너 목록 보기 (실행 중 및 중지됨)
docker ps -a
# 실행 중인 컨테이너 중지
docker stop <container_name>
# 중지된 컨테이너 제거
docker rm <container_name>
# Docker 이미지 제거
docker rmi <image_name>
# 컨테이너의 로그 보기
docker logs <container_name>
# 모든 볼륨 목록 보기
docker volume ls
# 특정 볼륨 제거
docker volume rm <volume_name>
# 모든 사용하지 않는 컨테이너, 네트워크, 이미지 제거 (댕글링 이미지 포함)
docker system prune -f
# 모든 사용하지 않는 컨테이너, 네트워크, 이미지, 볼륨 제거
docker system prune --all --volumes --force -f
# 모든 중지된 컨테이너 제거
docker container prune -f
# 사용하지 않는 이미지 제거
docker image prune -f
# 사용하지 않는 볼륨 제거
docker volume prune -f


---------------------------------------------------------------------------------------------------- Networking
# ssh-config(~/.ssh/config) 읽어서 host 선택하고 접속
ssh_from_ssh-config
# 내꺼
ssh -i ~/.ssh/dev-server.pem ubuntu@3.39.132.9

# Connect to a Wi-Fi network, prompting for a password
nmcli device wifi connect <SSID> --ask

nmcli -s -g 802-11-wireless-security.psk connection show $(nmcli connection show | grep -i wifi |awk '{print $1 "\t" $3 "\t"  $4}'| column -t -s $'\t' | fzf | awk '{print $1}')

# Check network link status for a specific interface
ip link show

# 공인아이피 확인
curl https://api.ipify.org

# sshfs
sshfs -o IdentityFile=~/.ssh/dev-server.pem,reconnect,ServerAliveInterval=15,ServerAliveCountMax=3 ubuntu@3.39.132.9:/home/ubuntu/sshfs ~/jg/05.NMM/sshfs
# 일반적인 언마운트 시도
fusermount3 -u ~/ec2_mount

# SSH 키 생성 (기본 RSA 키)
ssh-keygen -t rsa -b 4096 -C "<your_email@example.com>"

# SSH 접속 (호스트 별칭 사용, ~/.ssh/config에 설정된 경우)
ssh -i "<path/to/ssh-key.pem>" <username>@<host>

# 파일 전송 (remote   local)
scp <user>@<hostname>:/<remote/path>/<remotefile.txt> <local/path>/

# 디렉토리 전송 (local   remote)
scp -r <localdir> <user>@<hostname>:/<remote/path>/

# rsync로 디렉토리를 동기화 (local   remote, 압축 및 아카이브 모드 및 진행률)
rsync -avzP <localdir>/ <user>@<hostname>:/<remote/path>/

# rsync로 디렉토리를 동기화 (remote   local)
rsync -avzP <user>@<hostname>:/<remote/path>/ <localdir>/

# 포트 포워딩 (로컬 포트 8080을 원격 서버의 80으로 노출)
ssh -L 8080:localhost:80 <user>@<hostname>

# SSH 터널을 통해 SOCKS 프록시 설정 (동적 프록시, remote를 프록시 서버로)
ssh -D 1080 <user>@<hostname>

# 원격 서버에서 명령 실행 (접속 없이)
ssh <user>@<hostname> "<command>"



---------------------------------------------------------------------------------------------------- remote dev

# 동기화 세션 생성 (로컬   원격, 양방향 동기화 시작), --name: 별칭, --ignore-vcs: .gitignore 준수
mutagen sync create --ignore-vcs <local/path> <ssh_alias>:<remote/path> --name=<session_name>

# 동기화 일시 정지 (세션 설정은 유지하되, 파일 전송만 멈춤)
mutagen sync pause <session_name>

# 동기화 재개 (일시 정지된 세션을 다시 시작)
mutagen sync resume <session_name>

# 동기화 세션 영구 삭제 (더 이상 동기화하지 않을 때)
mutagen sync terminate <session_name>

# 현재 실행 중인 모든 동기화 세션 상태 확인 (상태, 충돌 여부 등)
mutagen sync list

# Mutagen 데몬(백그라운드 프로세스) 전체 종료 (다시 명령어를 입력하면 자동으로 재시작됨)
mutagen daemon stop

# 특정 세션의 동기화 과정을 실시간으로 모니터링 (종료하려면 Ctrl+C)
mutagen sync monitor <session_name>

# 동기화 강제 적용 (변경사항이 반영되지 않았을 때 즉시 동기화 시도)
mutagen sync flush <session_name>



---------------------------------------------------------------------------------------------------- find & fd
# Find all .txt files in current directory
find . -name "*.txt"
# Find files modified in last 7 days
find . -mtime -7
# Find and delete .log files
find . -name "*.log" -exec rm {} \;
# Find directories only
find . -type d
# file a or b
find . -name '*.c' -o -name '*.h'


# Find all .md files with fd
fd "\.md$"
# Find files with 'test' in name
fd test
# Find .txt files and open with vim
fd -e txt -x vim {}
# Case-insensitive search in specific dir
fd -i pattern /path/to/dir
# fd: Find .md files AND larger than 1KB
fd -e md --size +1k
# fd: Find files with 'test' OR 'example' in name
fd "test|example"


---------------------------------------------------------------------------------------------------- disasm

# Display private headers (program headers) of the ELF file
objdump -p <file> | vi -c "set ft=asm"

# Disassemble the executable sections of the ELF file
objdump -d <file> | vi -c "set ft=asm"

# Display file header information of the ELF file
objdump -f <file> | vi -c "set ft=asm"

# Display program headers and segment information using readelf
readelf -l <file> | vi -c "set ft=asm"


---------------------------------------------------------------------------------------------------- aws configuration
# 기본 리전 설정 (설정 후에는 --region 생략 가능)
aws configure set region ap-northeast-2
# 설정된 프로필 확인
aws configure list
# 현재 IAM 자격 증명 확인
aws sts get-caller-identity

---------------------------------------------------------------------------------------------------- aws ec2 (Read -> Manage)
# [조회] 실행 중인 인스턴스 목록 (ID, 이름, 상태, IP, 타입)
aws ec2 describe-instances --filters "Name=instance-state-name,Values=running" --query "Reservations[*].Instances[*].{ID:InstanceId,Name:Tags[?Key=='Name']|[0].Value,State:State.Name,IP:PublicIpAddress,Type:InstanceType}" --output table

# [조회] 사용 가능한 AMI 목록 (내 계정 소유)
aws ec2 describe-images --owners self --query "Images[*].{ID:ImageId,Name:Name,Created:CreationDate}" --output table

# Ubuntu (Canonical) AMI
aws ec2 describe-images --owners 099720109477 --output json

 aws ec2 describe-images --owners 099720109477 --output json | jq '.Images[] | select(.Description | contains("amd64"))'

# Amazon Linux AMI
aws ec2 describe-images --owners amazon --output json

# instance type 조회
aws ec2 describe-instance-types --output json

# instance type 주요 요소 조회 및 필터링
aws ec2 describe-instance-types --output json | jq '.InstanceTypes[] | {InstanceType, CurrentGeneration, FreeTierEligible, ProcessorInfo, VCpuInfo, MemoryInfo, NetworkInfo} | select(.InstanceType | contains("t3."))'

# [관리] 인스턴스 시작/중지/재부팅
aws ec2 start-instances --instance-ids <instance-id>

aws ec2 stop-instances --instance-ids <instance-id>

aws ec2 reboot-instances --instance-ids <instance-id>

aws ec2 modify-instance-attribute --instance-id <instance-id> --instance-type <instance-type>

# [관리] 인스턴스 생성 (최소 설정)
aws ec2 run-instances --image-id <ami-id> --count 1 --instance-type t2.micro --key-name <key-pair-name>

# [삭제] 인스턴스 종료 (삭제)
aws ec2 terminate-instances --instance-ids <instance-id>


# 인스턴스 태그 create/update
aws ec2 create-tags --resources <instance-id> --tags Key=<tag-name>,Value=<tag-value>
# 인스턴스 태그 delete
aws ec2 delete-tags --resources <instance-id> --tags Key=<tag-name>

# [조회] EBS 볼륨 목록 (ID, 크기, 상태, 타입, 연결된 인스턴스)
aws ec2 describe-volumes --query "Volumes[*].{ID:VolumeId,Size:Size,State:State,Type:VolumeType,InstanceId:Attachments[0].InstanceId}" --output table

# [조회] 특정 EBS 볼륨 상세 정보
aws ec2 describe-volumes --volume-ids <volume-id>

# [관리] EBS 볼륨 생성 (예: 10GB gp3 타입, 특정 가용 영역)
aws ec2 create-volume --size 10 --volume-type gp3 --availability-zone <availability-zone>

# [관리] EBS 볼륨 연결 (인스턴스에 /dev/sdf로 연결)
aws ec2 attach-volume --volume-id <volume-id> --instance-id <instance-id> --device /dev/sdf

# [관리] EBS 볼륨 분리
aws ec2 detach-volume --volume-id <volume-id>

# [관리] EBS 볼륨 크기 수정 (예: 20GB로 확장)
aws ec2 modify-volume --volume-id <volume-id> --size 20

# [삭제] EBS 볼륨 삭제
aws ec2 delete-volume --volume-id <volume-id>

---------------------------------------------------------------------------------------------------- aws key-pair & security-group
# [조회] 키 페어 목록 (이름, 지문)
aws ec2 describe-key-pairs --query "KeyPairs[*].{Name:KeyName,Fingerprint:KeyFingerprint}" --output table
# [관리] 키 페어 생성 (생성된 키는 파일로 저장해야 함)
aws ec2 create-key-pair --key-name <new-key-name> --query "KeyMaterial" --output text > <new-key-name>.pem
# [삭제] 키 페어 삭제
aws ec2 delete-key-pair --key-name <key-name>

# [조회] 보안 그룹 목록 (ID, 이름, 설명, VPC ID)
aws ec2 describe-security-groups --query "SecurityGroups[*].{ID:GroupId,Name:GroupName,Desc:Description,VpcId:VpcId}" --output table
# [조회] 특정 보안 그룹의 인바운드 규칙 확인
aws ec2 describe-security-groups --group-ids <sg-id> --query "SecurityGroups[*].IpPermissions"
# [관리] 보안 그룹 생성
aws ec2 create-security-group --group-name <sg-name> --description "My security group"
# [관리] 인바운드 규칙 추가 (예: SSH 22번 포트 허용)
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 22 --cidr 0.0.0.0/0
# [삭제] 보안 그룹 삭제
aws ec2 delete-security-group --group-id <sg-id>

---------------------------------------------------------------------------------------------------- aws lambda (Read -> Manage)
# [조회] 함수 목록 확인 (이름, 런타임, 마지막 수정일)
aws lambda list-functions --query "Functions[*].{Name:FunctionName,Runtime:Runtime,LastModified:LastModified}" --output table
# [조회] 특정 함수 상세 정보
aws lambda get-function --function-name <function-name>
# [관리] 함수 실행 (결과는 response.json에 저장)
aws lambda invoke --function-name <function-name> response.json
# [관리] 함수 코드 업데이트 (zip 파일 업로드)
aws lambda update-function-code --function-name <function-name> --zip-file fileb://function.zip
# [삭제] 함수 삭제
aws lambda delete-function --function-name <function-name>

---------------------------------------------------------------------------------------------------- aws s3 (Read -> Manage)
# [조회] 버킷 목록
aws s3 ls
# [조회] 버킷 내용 확인
aws s3 ls s3://<bucket-name>
# [조회] 버킷 메타데이터
aws s3api head-bucket --bucket <bucket-name>
# [조회] 버킷 정책 확인
aws s3api get-bucket-policy --bucket <bucket-name>
# [관리] 버킷 생성
aws s3 mb s3://<new-bucket-name>
# [관리] 파일 업로드
aws s3 cp <local-file> s3://<bucket-name>/
# [관리] 파일 다운로드
aws s3 cp s3://<bucket-name>/<file> <local-path>
# [관리] 파일 동기화
aws s3 sync <local-dir> s3://<bucket-name>/
# [삭제] 객체 삭제 및 버킷 삭제
aws s3 rm s3://<bucket-name>/<file-path>
# [!주의! 강제 삭제] 파일이 있어도 버킷 통째로 삭제
aws s3 rb s3://<bucket-name> --force
